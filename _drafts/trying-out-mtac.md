---
layout: post
category: reflections
tags:
 - coq
 - Mtac
title: Experimenting with Mtac
author: gregory malecha
highlight: true
extra_js_head:
- "https://www.google.com/jsapi?autoload={'modules':[{'name':'visualization','version':'1','packages':['corechart']}]}"
---

I spent some time a few months ago experimenting with [Mtac](http://plv.mpi-sws.org/mtac/) and figured that I'd write a little bit about my experience.
Mtac is a tactic language for Coq where you get write Gallina terms that manipulate raw Coq syntax through a monadic interface.

You can get the (extensively commented) full source code at as [gist](https://gist.github.com/gmalecha/62cbdbe0f40edc7db258).

## Equality in a Commutative Monoid ##

I opted to explore Mtac by building a procedure for proving equalities in a commutative monoid. Since I don't want to bother formalizing commutative monoids I'll just axiomatize them to keep the dependencies small.

~~~coq
Parameter m : Type. (* type of the monoid *)
Parameter star : m -> m -> m.
Local Infix "*" := star.
Parameter one : m.

(* commutative *)
Axiom star_comm  : forall a b : m, a * b = b * a.
(* associative *)
Axiom star_assoc : forall a b c : m, (a * b) * c = a * (b * c).
(* one is neutral *)
Axiom one_star   : forall a : m, one * a = a.
~~~

Using just these theorems it is not too difficult to prove this goal, but the result is quite ugly.

~~~coq
Goal forall a b c : m, a * b * c = c * b * a.
Proof.
  intros.
  rewrite star_assoc. rewrite (star_comm _ a).
  rewrite (star_comm c b). reflexivity.
Qed.
~~~

Of course this quickly gets cumbersome so I'll use Mtac to write some automation.

## Mtac Basics ##

The idea of Mtac is fairly simple, the Mtac plugin comes equipped with a monad ```M``` of Mtac tactics that can be used to write automation. In addition to the standard ```bind``` and ```return``` that all monads have, ```M``` also comes equipped with a bunch of operations that are not kosher in Gallina, but are exactly what is needed to inspect terms and build proofs. In particular, it comes with a ```mmatch``` operation that allows Mtac programs to inspect the *syntax* of a Gallina term similar to what Ltac's ```match``` allows you to do. To give just a flavor of how it works, here's an example of using ```mmatch``` to optimize ```star```.

~~~coq
Definition opt_star (a b : m) : M { x : m | x = star a b }.
refine (
  mmatch a as a return M { x : m | x = star a b } with
  | emp => ret (@exist _ _ b _ (* first proof *))
  | [? z] z =>
    mmatch b as b return M { x : m | x = star z b } with
    | emp => ret (@exist _ _ a _ (* second proof *))
    | _ => ret (@exist _ _ (star a b) _ (* third proof *))
    end
  end).
~~~

The goal of ```opt_star``` is to construct a value that is equal to ```a * b``` but does not star together units, i.e. ```one * a = a``` and ```a * one = a```. Mtac matches are required to return values in the monad, and, like Coq's standard dependent pattern matching, they are dependent, i.e. the type of each branch depends on the pattern that is matched.

I'll use tactics to fill in the three proof obligations that arise from the commented holes in the term. The first one says the following:

~~~coq
a, b : m
e : a = emp
============================
b = star emp b
~~~

Which is easy to solve using ```one_star```.

~~~coq
clear; abstract (symmetry; apply emp_star).
~~~

Here ```abstract``` treats the result of the tactic as opaque. ```abstract X``` constructs a new definition with the given type and solves it using ```X``` (note that ```X``` must completely solve the goal). Then it solves the goal by appealing directly to the proof. The other two proofs can be solved in a similar way.

The ```Mrun``` "function" runs the Mtac program [^fn-mrun].

~~~coq
Let x := Mrun (mstar emp emp).
Print x.
(* x = exist (fun x : m => x = star emp emp) emp (mstar_subproof emp)
 *    : {x : m | x = star emp emp}
 *)
~~~

```Mrun``` interprets the monadic program and replaces it with the result. Here, we see that, as the type states, the result is a pair of a term ```x``` which is ```emp``` and a proof of ```emp = mstar emp emp``` (```mstar_subproof emp```, the lemma name generated by ```abstract```).

## Implementing a Canceller ##

To implement the canceller, I'm going to break the problem down into two phases. In the first phase, the automation will iterate through atomic elements on the left-hand side. If it is ```one``` then it will drop the element and continue. Otherwise, it will attempt to find a matching term on the right-hand side. If the automation can find a matching element, it can drop both terms; otherwise, it keeps the term on the left and continues the iteration.

To look at performance (which will be a thread throughout the rest of the post) I constructed the following simple code to construct arbitrarily sized problems.

~~~coq
Require Import Coq.Lists.List.
Axiom asM : nat -> m. (** Just a way to construct 'm's **)

(** Build a large 'm' from a list. **)
Fixpoint big (n : nat) : list m :=
  match n with
  | 0 => nil
  | S n => asM n :: big n
  end.

Fixpoint stars (l : list m) : m :=
  match l with
  | nil => one
  | l :: nil => l
  | l :: ls => l * stars ls
  end.

(** This will allow us to set up problems that are reasonably 'difficult'
 ** to solve.
 **)
Definition benchmark (n : nat) : Prop :=
  stars (big n) = stars (rev (big n)).

Ltac bench n :=
  let p := eval compute in (benchmark n) in
  refine p.

Goal ltac:(bench 3).
 (* asM 2 * (asM 1 * asM 0) = asM 0 * (asM 1 * asM 2) *)
Abort.
~~~
Since the high-level cancellation function clearly depends on the ```remove``` program, I'll start by writing that function.

### A First Attempt ###

My first attempt to implement the ```remove``` function was the following. I'm usually not a user of ```Program``` but I was told that it was useful for writing Mtac code so I figured I would give it a try.

~~~coq
(** An Mtac exception **)
Definition NotFound : Exception.
  exact exception.
Qed.

Program Definition remove (x : m)
: forall s, M { s' : m | s = x * s' } :=
  (mfix1 f (s : m) : M { s' : m | s = x * s' } :=
    mmatch s as s return M { s' : m | s = x * s' } with
    | x => ret (@exist _ _ one _)
    | [? l r ] star l r =>
      mtry
        il <- f l ;
        ret (@exist _ _ (il * r) _)
      with _ =>
        ir <- f r ;
        ret (@exist _ _ (l *ir) _)
      end
    | _ => raise NotFound
    end).
Next Obligation.
  clear.
  rewrite star_comm. symmetry. apply one_star.
Qed.
Next Obligation.
  clear.
  simpl. rewrite star_assoc. reflexivity.
Qed.
Next Obligation.
  clear.
  simpl. rewrite <- star_assoc. rewrite (star_comm l x0). rewrite star_assoc.
  reflexivity.
Qed.
~~~

Here I'm using Mtac's ```mfix1``` to construct a recursive tactic on a single argument.
The procedure is similar to the definition of ```opt_star``` above: the tactic returns a pair of a result and proof connecting the result to the input.
In order to express that the element was not found, I am using Mtac's exception mechanism which is built into the ```Mtac``` monad.
As above, I solve the subgoals with abstracted proofs.

```Program``` made the implementation quite simple, but the resulting proof terms are really bad. For example, removing a single term from a star of 10 terms produces a term that is 124 lines long. Looking at the proof term, we see that the automation is embedded inside the proof term.

~~~coq
Time Check Mrun (remove (asM 9) (stars (big 10))).
(** exist (fun s' : m => asM 9 * stars (big 9) = asM 9 * s')
  (proj1_sig
     (exist (fun s' : m => asM 9 = asM 9 * s') one
        (remove_obligation_1 (asM 9)
           (tfix1' M (fun (a : Type) (x : M a) => x)
              (fun (f : forall x : m, M ((fun s : m => {s' : m | s = asM 9 * s'}) x)) (s : m) => (* ... this is a copy of the automation ... *) ...
~~~

To understand the problem, it is important to understand Mtac's evaluation strategy.

> **Mtac Evaluation.**
> Mtac's evaluation strategy is lazy, it uses Coq's head normal formal evaluation strategy to uncover the next monadic operation (since these are defined as an inductive type) and then implements it in the OCaml plugin. For example, to implement ```bind``` (written ```x <- c ; k```) it evaluates the first argument and, if it is a ```ret``` then it substitutes the argument in the body (```k```) and continues reducing. This is important for implementing ```mmatch``` because it ensures that the term that you are matching on is not reduced which would change its syntactic representation (and therefore the results of the match since the match is on the syntax).

With this understanding we can look at implementation that ```Program``` constructed for us:

~~~coq
remove =
fun x : m =>
mfix1 f (s : m) : M {s' : m | s = x * s'} :=
   (mmatch s as s0 return M {s' : m | s0 = x * s'}
    with x =c> [H]
       ret (exist (fun s' : m => x = x * s') one (remove_obligation_1 x f s H))
    |  [?l r : m] l * r =c> [H]
       ttry
         (il <- f l;
       	  ret
            (exist (fun s' : m => l * r = x * s') (proj1_sig il * r)
                   (remove_obligation_2 x f s l r H il)))
         (fun e : Exception =>
           tmatch (fun _ : Exception => {s' : m | l * r = x * s'}) e
                  ((with [?x0 : Exception] x0 =c> [H0]
                     ir <- f r;
                     ret
                       (exist (fun s' : m => l * r = x * s')
                              (l * proj1_sig ir)
                              (remove_obligation_3 x f s l r H e x0 H0 ir)) end) ++
                   (with [?x0 : Exception] x0 =c> [_]
                      raise x0 end)))| [?x0 : m] x0 =c> [_] raise NotFound
      end)
     : forall x s : m, M {s' : m | s = x * s'}
~~~

The issue is the number of arguments to the proof obligations constructed by ```Program```. For example, ```remove_obligation_3``` is applied to 10 arguments, none of which will be reduced by Mtac's reduction mechanism. Further, the modular implementation of ```mfix1``` simply substitutes itself in the body which can make these arguments quite large.

### Revising the Automation with the Proof in Mind ###

There are two main things that we can do to make better proof terms.

  1. Lift matches so that ```Mrun``` reduces them by making sure that they return
     values of type ```M```.
  2. Avoid using ```Program``` to get finer granularity control over the obligations and term that is constructed.

Of the two, the first is the more important. Adopting these two techniques yields the following definition:

~~~coq
Definition remove_refine (x : m)
: forall (s : m), M { s' : m | s = x * s' }.
refine
  (mfix1 f (s : m) : M { s' : m | s = x * s' } :=
    mmatch s as s return M { s' : m | s = x * s' } with
    | x => ret (@exist _ _ one _)
    | [? l r ] star l r =>
      mtry
        il <- f l ;
        match il with
        | exist _ il1 il2 =>
          ret (@exist _ _ (il1 * r) _)
        end
      with _ =>
        ir <- f r ;
        match ir with
        | exist _ ir1 ir2 =>
          ret (@exist _ _ (l * ir1) _)
        end
      end
    | _ => raise NotFound
    end).
{ clear - e.
  abstract (rewrite star_comm; symmetry; apply one_star). }
{ clear - e il2.
  abstract (subst; rewrite star_assoc; reflexivity). }
{ clear - e0 e1 ir2.
  abstract (subst; rewrite <- star_assoc; rewrite (star_comm l x0);
            rewrite star_assoc; reflexivity). }
Defined.
~~~

If you inspect the term using ```Print``` then you will note that it is a bit simpler. The main difference, however, can be seen when we look at the proof term from our simple result.

~~~coq
Check Mrun (remove_refine (asM 9) (stars (big 16))).
~~~

The proof is now 16 lines (10x smaller) and takes less than a tenth of a second to construct. That's a **75x performance improvement** just from doing explicit pattern matches which were causing the automation to be embedded in the final proof.

### Cancellation ###

The [accompanying gist]() has a similar comparison for the implementation of ```cancel``` but the ideas are mostly the same. The best implementation of ```cancel``` that I was able to write was the following:

~~~coq
Definition cancel_refine
: forall (l r : m), M { xy : m * m
                      | forall Z, match xy with
                                  | (x,y) => Z * x = y -> Z * l = r
                                  end }.
refine (
  mfix2 cancel (l : m) (r : m)
  : M { xy : m * m
      | forall Z, match xy with
                  | (x,y) => Z * x = y -> Z * l = r
                  end} :=
    mmatch l as l
      return M { xy : m * m
               | forall Z, match xy with
                           | (x,y) => Z * x = y -> Z * l = r
                           end }
    with
    | [? a' a''] star a' a'' =>
      res <- cancel a' r ;
      match res with
      | exist _ _res1 _res2 =>
        (** NOTE the explicit pattern matching and casting! **)
        match _res1 as res1
              return (forall Z, match res1 with
                                | (x,y) => Z * x = y -> Z * _ = _
                                end) -> _
        with
        | (fst_res1,snd_res1) => fun res2 =>
          res' <- cancel a'' (snd_res1) ;
          match res' with
          | exist _ _res'1 _res'2 =>
	    (** NOTE the explicit pattern matching and casting! **)
            match _res'1 as res1
                  return (forall Z, match res1 with
                                    | (x,y) => Z * x = y -> Z * _ = _
                                    end) -> _
            with
            | (fst_res'1,snd_res'1) => fun res'2 =>
              ret (@exist _ _ (fst_res1 * fst_res'1, snd_res'1) _)
            end _res'2
          end
        end _res2
      end
    | _ =>
      mtry
        res <- remove_refine l r ;
        match res with
        | exist _ res1 res2 =>
          ret (@exist _ _ (one, res1) _)
        end
      with _ =>
        ret (@exist _ _ (l, r) _)
      end
    end).
(** Proofs elided **)
Defined.
~~~

At the high level, the type of ```cancel_refine``` states that it takes in two monoidal expressions and returns a pair of monoidal expressions such that if the returned expressions are equal, then the input expressions are equal.
However, to implement the function, we need to strengthen the recursion by introducing an extra variable ```Z``` that we star with both left-hand sides.
This allows us to use returned results in the calling context and is analagous to strengthening the inductive hypothesis. To see why you need this, try removing the extra quantification and see where things go wrong. We can use the following theorem to convert the result of the automation to a usable form.

~~~coq
Theorem finish_cancel (a b c d : m)
        (pf : forall Z, Z * c = d -> Z * a = b)
  : c = d -> a = b.
Proof.
  intros. specialize (pf one). subst.
  repeat rewrite one_star in *. auto.
Qed.

Ltac solve_it :=
  match goal with
  | |- @eq m ?X ?Y =>
    let z := constr:(Mrun (cancel_refine X Y)) in
    match z with
    | @exist _ _ _ ?pf =>
      apply (@finish_cancel _ _ _ _ pf) ; reflexivity
    end
  end.
~~~

The crucial part of the implementation is the two pattern matches called out in the code with the ```NOTE```s. Without these pattern matches the code takes 27seconds to prove the size 5 benchmark, with the pattern matches that time goes down to 0.076 seconds (a 355x speedup).

### Performance ###

The final implementation of cancellation performs pretty well but it does take a lot of care to get there. In particular, it is really important that you inspect the resulting proof terms to ensure that you are not duplicating too much information. The chart shows how the optimized Mtac automation compares to the standard Ltac implementation of cancellation on various problem sizes [^fn-chart].

<div id="mtac-perf"></div>

<script type="text/javascript">
    function drawChart() {
      var data = google.visualization.arrayToDataTable([
        ['Size', 'Ltac' , 'Ltac-Qed',  'Mtac', 'Mtac-Qed', 'Rtac', 'Rtac-Qed'],
        [3,      0.007  , 0.001     , 0.038  , 0.006     , 0.020 , 0.092 ],
        [5,      0.017  , 0.002     , 0.108  , 0.019     , 0.027 , 0.124 ],
        [10,     0.125  , 0.011     , 0.302  , 0.101     , 0.050 , 0.201 ],
        [20,     1.416  , 0.062     , 1.541  , 0.393     , 0.099 , 0.339 ],
        [50,     43.206 , 0.666     , 35.665 , 9.851     , 0.341 , 0.925 ],
        [75,     229.533, 2.338     , 168.192, 45.569    , 0.530 , 1.255 ],
        [100,    737.690, 5.334     , 519.238, 133.901   , 0.885 , 1.830 ],
      ]);

      var options = {
        title: 'Mtac Performance',
        curveType: 'function',
        legend: { position: 'bottom' },
        vAxis : { scaleType: 'log' , max: 25
                , viewWindow : { max: 35 }
                , viewWindowMode: 'explicit' },
      };

      var chart = new google.visualization.LineChart(document.getElementById('mtac-perf'));

      chart.draw(data, options);
    }
    google.setOnLoadCallback(drawChart);
</script>

Even after all of the optimization, Mtac doesn't come close to the speed of
[computational reflection]({% post_url 2016-02-20-rtac-technical-overview %}), e.g. the [Rtac](https://github.com/gmalecha/mirror-core) implementation of cancellation solves problems of size 100 in under a second while Mtac takes 5 seconds on a problem of size 30. While it isn't very common to have such large problems, it is not uncommon when stitching automation together. For example, program verification might result in tens of calls to an entailment checker each with a goal of perhaps 10 or so conjuncts. Stitching all of these proofs together along with the reasoning about the program can quickly become costly.

## Final Thoughts ##

Mtac is quite convenient and light-weight to use; however, getting good performance can be a bit tricky. The main thing that you need to understand to write reasonably efficient Mtac tactics is the evaluation mechanism. The various iterations took some time but the optimizations are well worth it (over a 1000x speedup).

While you could chalk this up to implementation, to me there seems to be something more here. Constructing the proof term within the function is convenient, the type confuses what is happening. Even though you have equalities in the context, if your function attempts to eliminate them in the wrong place everything the term will get stuck and ultimately fail.

Mtac does allow you to write tactics in a typed manner, but it still generates proof objects. While the terms that it constructs are not immediately re-checked by the system, they are re-checked at ```Qed``` time. Coq 8.5's ```uconstr``` feature removes some of the type checking overhead of naive Ltac, but Mtac still seems to be a lot nicer.

The benefit of Mtac over computational reflection, is that Mtac
completely avoids the need for a reflective representation which
decreases the up-front cost to using it and trivially addresses the
entire language including complex dependent types.

[^fn-mrun]: ```Mrun``` is not really a "function" in the Coq sense of the term because it does not respect equality. Essentially, if ```a = b```, ```Mrun a``` is *not* necessarily equal to ```Mrun b```.

[^fn-chart]: Results for Ltac and Rtac are taken from [Extensible and Efficient Automation through Reflective Tactics, ESOP'16]({% post_url 2016-01-01-extensible-and-efficient-automation-through-reflective-tactics %}).